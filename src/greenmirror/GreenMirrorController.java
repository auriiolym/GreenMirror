package greenmirror;

import greenmirror.commandlineoptionhandlers.HelpCommandLineOptionHandler;

import joptsimple.OptionException;
import joptsimple.OptionParser;
import joptsimple.OptionSet;
import org.eclipse.jdt.annotation.NonNull;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.net.Socket;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.TreeSet;

/**
 * The base controller. It contains shared functionality for the client and server 
 * implementations.
 * 
 * @author Karim El Assal
 */
public abstract class GreenMirrorController {

    // -- Instance variables -----------------------------------------------------------------
    
    /** all <code>Node</code>s currently tracked by GreenMirror */
    //@ private invariant nodes == getNodes();
    @NonNull private NodeList nodes = new NodeList();
    
    /** the input stream from the peer */
    //@ private invariant getStreamIn() == streamIn;
    private BufferedReader streamIn;
    
    /** the output streams to the peer */
    //@ private invariant getStreamOut() == streamOut;
    private BufferedWriter streamOut;
    
    /** the socket connection with the peer */
    //@ private invariant getSocket() == socket;
    private Socket socket;

    /** all registered <code>CommandHandler</code>s */
    @NonNull private List<CommandHandler> commandHandlers = new LinkedList<CommandHandler>();
    
    /** all registered <code>CommandLineOptionHandler</code>s */
    @NonNull private List<CommandLineOptionHandler> registeredCommandLineOptionHandlers 
                                                    = new LinkedList<CommandLineOptionHandler>();
    
    /** The communication format used for network communication */
    @NonNull private CommunicationFormat communicationFormat = CommunicationFormat.JSON;
    
    
    // -- Constructors -----------------------------------------------------------------------
    
    // -- Queries ----------------------------------------------------------------------------
    
    /**
     * Gets the help message that is associated with the command line usage of the application.
     * The first %s will be replaced by the help screen generated by JOpt Simple.
     * 
     * @return the help message
     * @see    HelpCommandLineOptionHandler
     */
    /*@ pure */ @NonNull public abstract String getHelpMessage();
    
    /** @return the reference to the list of <code>Node</code>s */
    /*@ pure */ @NonNull public NodeList getNodes() {
        return nodes;
    }
    
    /**
     * Gets a <code>NodeList</code> which only contains the name and/or type specified in 
     * <code>identifier</code>.
     * 
     * @param identifier the name/type identifier. See {@link greenmirror.Node.Identifier}
     * @return           the list
     */
    /*@ pure non_null */ public NodeList getNodes(@NonNull String identifier) {
        return getNodes().withIdentifier(identifier);
    }

    /**
     * Gets a <code>Node</code> by its id.
     * 
     * @param id the <code>Node</code>'s id
     * @return   the <code>Node</code>
     * @throws IllegalArgumentException if the id was not found
     */
    /*@ pure */ @NonNull public Node getNode(@NonNull Integer id) {
        for (Node node : getNodes()) {
            if (id.equals(node.getId())) {
                return node;
            }
        }
        throw new IllegalArgumentException("id " + id + " does not belong to a node");
    }

    /** @return the incoming stream; <code>null</code> if there is none */
    /*@ pure */ public BufferedReader getStreamIn() {
        return streamIn;
    }

    /** @return the outgoing stream; <code>null</code> if there is none */
    /*@ pure */ public BufferedWriter getStreamOut() {
        return streamOut;
    }

    /** @return the socket; <code>null</code> none if there is none */
    /*@ pure */ public Socket getSocket() {
        return socket;
    }

    /** @return all registered <code>CommandHandler</code>s */
    /*@ pure */ @NonNull public List<CommandHandler> getCommandHandlers() {
        return commandHandlers;
    }
    
    /** @return all registered <code>CommandLineOptionHandler</code>s */
    /*@ pure */ @NonNull public List<CommandLineOptionHandler> getCommandLineOptionHandlers() {
        return this.registeredCommandLineOptionHandlers;
    }

    /** @return the communication format used for network communication */
    /*@ pure */ @NonNull public CommunicationFormat getCommunicationFormat() {
        return communicationFormat;
    }

    
    // -- Setters ----------------------------------------------------------------------------

    /** @param in the incoming stream to set */
    //@ ensures getStreamIn() == in;
    public void setStreamIn(BufferedReader in) {
        this.streamIn = in;
    }

    /** @param out the outgoing stream to set */
    //@ ensures getStreamOut() == out;
    public void setStreamOut(BufferedWriter out) {
        this.streamOut = out;
    }

    /** @param socket the socket to set */
    //@ ensures getSocket() == socket;
    public void setSocket(Socket socket) {
        this.socket = socket;
    }

    /** @param handler the command handler to register */
    //@ ensures getCommandHandlers().contains(handler);
    //@ ensures this.equals(handler.getController());
    public void register(@NonNull CommandHandler handler) {
        getCommandHandlers().add(handler);
        handler.setController(this);
    }

    /** @param format the communication format to set */
    //@ ensures getCommunicationFormat() == format;
    public void setCommunicationFormat(@NonNull CommunicationFormat format) {
        this.communicationFormat = format;
    }


    // -- Commands ---------------------------------------------------------------------------
    
    /** @param data raw data to send to the peer */
    public void send(@NonNull String data) {
        try {
            getStreamOut().write(data);
            getStreamOut().newLine();
            getStreamOut().flush();
        } catch (IOException e) {
            closeStreams();
        } catch (NullPointerException e) {
            Log.add("No connection available for sending data. ", e);
            closeStreams();
            return;
        }
        
        final String dataFormatted = data.replaceAll("(?s)\"image\":\"([\\d\\w\\+\\/-=]{40,}?)\"", 
                "\"image\":--removed for convenience--");
        Log.addVerbose("Data sent to peer: " + dataFormatted);
    }
    
    /** @param cmd <code>Command</code> to send to the peer */
    public void send(@NonNull Command cmd) {
        if (cmd.getController() == null) {
            cmd.setController(this);
        }
        cmd.prepare();
        send(cmd.getCommand() + ":" + cmd.getFormattedString(getCommunicationFormat()));
    }

    /**
     * Starts listening to the peer after checking if the listener has the current controller.
     *  
     * @param listener the <code>PeerListener</code> we're starting to listen to
     * @throws IllegalArgumentException if the controller is not properly set 
     */
    //@ requires this.equals(listener.getController());
    public void startPeerListener(@NonNull PeerListener listener) {
        if (!this.equals(listener.getController())) {
            throw new IllegalArgumentException("the peer listener needs a controller to send "
                    + "its received data to.");
        }
        
        listener.start();
    }

    /**
     * Closes the streams to and from the peer.
     */
    //@ ensures getSocket() == null && getStreamIn() == null && getStreamOut() == null;
    public synchronized void closeStreams() {
        try {
            getSocket().close();
            getStreamIn().close();
            getStreamOut().close();
            setSocket(null);
            setStreamIn(null);
            setStreamOut(null);
            
            Log.add("The connection with the peer has been closed.\n");
        } catch (IOException e) {
            Log.add("An IOException occured while closing the connection with the peer: ", e);
            // Don't do anything further with this.
        } catch (NullPointerException e) {
            // Streams have already been closed, don't do anything.
        }
    }

    /**
     * Handles raw data received from the peer.
     * 
     * @param data    the raw data
     * @param handler the handler that should handle the data
     */
    public abstract void handlePeerData(@NonNull String data, CommandHandler handler);
    
    
    /**
     * Processes the command line startup. The verbose option is handled hard-coded, the
     * rest of the command line options are handled by the registered command line option
     * handlers retrieved from {@link #getCommandLineOptionHandlers()}.
     * 
     * @param args the options passed via the command line
     * @return     <code>true</code> if the startup was successful
     * @see        #getCommandLineOptionHandlers()
     */
    public boolean processCommandLine(@NonNull String[] args) {
        
        final List<CommandLineOptionHandler> usedHandlers =
                                        new LinkedList<CommandLineOptionHandler>();
        
        // Set up the parser.
        final OptionParser parser = new OptionParser();
        for (CommandLineOptionHandler handler : getCommandLineOptionHandlers()) {
            handler.setParserSettings(parser);
        };
        // Hardcoded: add verbose option.
        GreenMirrorUtils.addCommandLineVerboseOption(parser);
        
        
        // Parse options.
        final OptionSet options;
        try {
            options = parser.parse(args);
        } catch (OptionException e) {
            Log.add("Something went wrong with parsing these options: " 
                    + new TreeSet<String>(e.options()).toString() 
                    + ". Are these valid options? Or did you forget to pass them? Use --help "
                    + "or -? to see all available options.");
            return false;
        }
        
        
        // Hardcoded: set verbose setting to true.
        if (options.has("verbose")) {
            Log.setVerbose(true);
            Log.addVerbose("Verbose output enabled.");
            Log.addVerbose("Arguments passed: " + Arrays.asList(args).toString());
        }
        
        // Validate option arguments.
        try {
            // Loop through all available option handlers.
            for (CommandLineOptionHandler optHandler : getCommandLineOptionHandlers()) {
                final String option = optHandler.getOptions().get(0);
                if (!options.has(option)) {
                    // Option wasn't passed and not required (or we'd already seen it: JOpt Simple
                    //  handles required options).
                    continue;
                }
                
                if (!options.hasArgument(option)) {
                    // Options without arguments don't need to be validated, but they do 
                    //  need to be used.
                    usedHandlers.add(optHandler);
                    continue;
                }
                
                // Get arguments of the option.
                List<?> optionArguments = options.valuesOf(option);
                for (int i = 0; i + optHandler.getArgumentCount() <= optionArguments.size();
                                i += optHandler.getArgumentCount()) {
                    final List<?> handlingArguments = optionArguments.subList(i, 
                                                        i + optHandler.getArgumentCount());
                    
                    // Account for multiple of the same arguments.
                    final CommandLineOptionHandler handler = optHandler.clone();
                    
                    // Validate
                    handler.validate(this, handlingArguments.toArray(new String[]{}));
                    
                    // Add to used handlers.
                    usedHandlers.add(handler);
                    
                    if (!optHandler.allowMultiple()) {
                        break;
                    }
                }
            }
        } catch (CommandLineOptionHandler.FatalException e) {
            // Validation went wrong. Show and exit.
            if (e.getThrowable() == null) {
                Log.add(e.getMessage());
            } else {
                Log.add(e.getMessage(), e.getThrowable());
            }
            return false;
        }
        
        
        // Restructure the argument handlers so we can process them according to their priority.
        final Map<Double, List<CommandLineOptionHandler>> map = 
                new TreeMap<Double, List<CommandLineOptionHandler>>();
        for (CommandLineOptionHandler argumentHandler : usedHandlers) {
            final List<CommandLineOptionHandler> handlerToAdd = 
                    new LinkedList<CommandLineOptionHandler>();
            handlerToAdd.add(argumentHandler);
            if (map.containsKey(argumentHandler.getProcessPriority())) {
                map.get(argumentHandler.getProcessPriority()).addAll(handlerToAdd);
            } else {
                map.put(argumentHandler.getProcessPriority(), handlerToAdd);
            }
        }

        // Process arguments in order.
        int handledArguments = 0;
        try {
            for (Map.Entry<Double, List<CommandLineOptionHandler>> entry : map.entrySet()) {
                for (CommandLineOptionHandler argumentHandler : entry.getValue()) {
                    argumentHandler.process(this);
                    handledArguments++;
                }
            }
        } catch (CommandLineOptionHandler.FatalException e) {
            // Validation went wrong. Only show the information. Exit is coming up.
            if (e.getThrowable() == null) {
                Log.add(e.getMessage());
            } else {
                Log.add(e.getMessage(), e.getThrowable());
            }
        }
        
        return handledArguments == usedHandlers.size();
    }

}