package greenmirror;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.net.Socket;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.TreeSet;

import joptsimple.OptionException;
import joptsimple.OptionParser;
import joptsimple.OptionSet;

/**
 * The base controller. It contains shared functionality for the client and server 
 * implementations.
 * 
 * @author Karim El Assal
 */
public abstract class GreenMirrorController {

    // -- Instance variables -----------------------------------------------------------------
    
    /**
     * All <tt>Node</tt>s.
     */
    //@ private invariant nodes != null && nodes == getNodes();
    private NodeList nodes = new NodeList();
    
    /**
     * The socket and input and output streams from and to the peer.
     */
    //@ private invariant getStreamIn() == streamIn;
    private BufferedReader streamIn;
    //@ private invariant getStreamOut() == streamOut;
    private BufferedWriter streamOut;
    //@ private invariant getSocket() == socket;
    private Socket socket;

    /**
     * All registered <tt>CommandHandler</tt>s.
     */
    //@ private invariant commandHandlers != null;
    private List<CommandHandler> commandHandlers = new LinkedList<CommandHandler>();
    
    /**
     * All registered <tt>CommandLineOptionHandler</tt>s.
     */
    //@ private invariant registeredCommandLineArguments != null;
    private List<CommandLineOptionHandler> registeredCommandLineOptionHandlers 
                                                                = new LinkedList<>();
    
    /**
     * The communication format used for network communication.
     */
    //@ private invariant communicationFormat != null;
    private CommunicationFormat communicationFormat = CommunicationFormat.JSON;
    
    /**
     * The instance that listens to data from the peer.
     */
    private PeerListener peerListener;
    
    // -- Constructors -----------------------------------------------------------------------
    
    // -- Queries ----------------------------------------------------------------------------
    
    /**
     * Get the help message that is associated with the command line usage of the application.
     * The first %s will be replaced by the help screen generated by JOpt Simple.
     * @return The help message.
     */
    //@ ensures \result != null;
    /*@ pure */ public abstract String getHelpMessage();
    
    /**
     * @return The reference to the list of <tt>Node</tt>s.
     */
    //@ ensures \result != null;
    /*@ pure */ public NodeList getNodes() {
        return nodes;
    }
    
    /**
     * Get a <tt>NodeList</tt> which only contains the name and/or type specified in 
     * <tt>identifierArg</tt>.
     * @param identifier The name/type identifier. {@link greenmirror.Node.Identifier}
     * @return           The list.
     */
    //@ requires identifierArg != null;
    //@ ensures \result != null;
    /*@ pure */ public NodeList getNodes(String identifier) {
        return getNodes().withIdentifier(identifier);
    }

    /**
     * Get a <tt>Node</tt> by its id.
     * @param id The <tt>Node</tt>'s id.
     * @return   The <tt>Node</tt> with id <tt>id</tt>.
     */
    //@ requires id != null;
    //TODO: do something with invalid ids.
    /*@ pure */ public Node getNode(Integer id) {
        for (Node node : getNodes()) {
            if (id.equals(node.getId())) {
                return node;
            }
        }
        return null;
    }

    /**
     * @return The incoming stream.
     */
    /*@ pure */ public BufferedReader getStreamIn() {
        return streamIn;
    }

    /**
     * @return The outgoing stream.
     */
    /*@ pure */ public BufferedWriter getStreamOut() {
        return streamOut;
    }

    /**
     * @return The socket.
     */
    /*@ pure */ public Socket getSocket() {
        return socket;
    }

    /**
     * @return All registered <tt>CommandHandler</tt>s.
     */
    //@ ensures \result != null;
    /*@ pure */ public List<CommandHandler> getCommandHandlers() {
        return commandHandlers;
    }
    
    /**
     * @return All registered <tt>CommandLineOptionHandler</tt>s.
     */
    //@ ensures \result != null;
    /*@ pure */ public List<CommandLineOptionHandler> getCommandLineOptionHandlers() {
        return this.registeredCommandLineOptionHandlers;
    }

    /**
     * @return The communication format used for network communication.
     */
    //@ ensures \result != null;
    /*@ pure */ public CommunicationFormat getCommunicationFormat() {
        return communicationFormat;
    }

    
    // -- Setters ----------------------------------------------------------------------------

    /**
     * @param in The incoming stream to set.
     */
    //@ ensures getStreamIn() == in;
    public void setStreamIn(BufferedReader in) {
        streamIn = in;
    }

    /**
     * @param out The outgoing stream to set.
     */
    //@ ensures getStreamOut() == out;
    public void setStreamOut(BufferedWriter out) {
        streamOut = out;
    }

    /**
     * @param socket The socket to set.
     */
    //@ ensures getSocket() == socket;
    public void setSocket(Socket socket) {
        this.socket = socket;
    }

    /**
     * @param handler The command handler to register.
     */
    //@ requires handler != null;
    //@ ensures getCommandHandlers().contains(handler);
    //@ ensures this.equals(handler.getController());
    public void register(CommandHandler handler) {
        getCommandHandlers().add(handler);
        handler.setController(this);
    }

    /**
     * @param format The communication format to set.
     */
    //@ ensures getCommunicationFormat() == format;
    public void setCommunicationFormat(CommunicationFormat format) {
        communicationFormat = format;
    }


    // -- Commands ---------------------------------------------------------------------------
    
    /**
     * @param data Raw data to send to the peer.
     */
    //@ requires data != null;
    public void send(String data) {
        try {
            getStreamOut().write(data);
            getStreamOut().newLine();
            getStreamOut().flush();
        } catch (IOException e) {
            closeStreams();
        } catch (NullPointerException e) {
            Log.add("No connection available for sending data. ", e);
            closeStreams();
            return;
        }
        Log.addVerbose("Data sent to peer: " + data);
    }
    
    /**
     * @param cmd <tt>Command</tt> to send to the peer.
     */
    //@ requires cmd != null;
    public void send(Command cmd) {
        if (cmd.getController() == null) {
            cmd.setController(this);
        }
        cmd.prepare();
        send(cmd.getCommand() + ":" + cmd.getFormattedString(getCommunicationFormat()));
    }

    /**
     * @param listener The <tt>PeerListener</tt> we're starting to listen.
     */
    //@ requires listener != null && this.equals(listener.getController());
    public void startPeerListener(PeerListener listener) {
        assert listener != null && this.equals(listener.getController());
        
        listener.start();
    }

    /**
     * Close the streams.
     */
    //@ ensures getSocket() == null && getStreamIn() == null && getStreamOut() == null;
    public synchronized void closeStreams() {
        try {
            getSocket().close();
            getStreamIn().close();
            getStreamOut().close();
            setSocket(null);
            setStreamIn(null);
            setStreamOut(null);
            
            Log.add("The connection with the peer has been closed.\n");
        } catch (IOException e) {
            Log.add("An IOException occured while closing the connection with the peer: ", e);
            // Don't do anything further with this.
        } catch (NullPointerException e) {
            // Streams have already been closed, don't do anything.
        }
    }

    /**
     * 
     * @param data
     */
    public abstract void handlePeerData(String data, CommandHandler handler);
    
    
    /**
     * Process the command line startup.
     * @param args The options passed via the command line.
     * @return     <tt>true</tt> if the startup was successful.
     */
    //@ requires args != null;
    public boolean processCommandLine(String[] args) {
        
        final List<CommandLineOptionHandler> usedHandlers = new LinkedList<>();
        
        // Set up the parser.
        final OptionParser parser = new OptionParser();
        getCommandLineOptionHandlers().forEach(handler -> {
            handler.setParserSettings(parser);
        });
        // Hardcoded: add verbose option.
        CommandLineOptionHandler.addVerboseOption(parser);
        
        
        // Parse options.
        final OptionSet options;
        try {
            options = parser.parse(args);
        } catch (OptionException e) {
            Log.add("Something went wrong with parsing these options: " 
                    + new TreeSet<String>(e.options()).toString() 
                    + ". Please check if they were passed correctly.");
            return false;
        }
        
        
        // Hardcoded: set verbose setting to true.
        if (options.has("verbose")) {
            Log.setVerbose(true);
            Log.addVerbose("Verbose output enabled.");
            Log.addVerbose("Arguments passed: " + Arrays.asList(args).toString());
        }
        
        // Validate option arguments.
        try {
            // Loop through all available option handlers.
            for (CommandLineOptionHandler optHandler : getCommandLineOptionHandlers()) {
                final String option = optHandler.getOptions().get(0);
                if (!options.has(option)) {
                    // Option wasn't passed and not required (or we'd already seen it: JOpt Simple
                    //  handles required options).
                    continue;
                }
                
                if (!options.hasArgument(option)) {
                    // Options without arguments don't need to be validated, but they do 
                    //  need to be used.
                    usedHandlers.add(optHandler);
                    continue;
                }
                
                // Get arguments of the option.
                List<?> optionArguments = options.valuesOf(option);
                for (int i = 0; i + optHandler.getArgumentCount() <= optionArguments.size();
                                i += optHandler.getArgumentCount()) {
                    final List<?> handlingArguments = optionArguments.subList(i, 
                                                        i + optHandler.getArgumentCount());
                    
                    // Account for multiple of the same arguments.
                    final CommandLineOptionHandler handler = optHandler.clone();
                    
                    // Validate
                    handler.validate(this, handlingArguments.toArray(new String[]{}));
                    
                    // Add to used handlers.
                    usedHandlers.add(handler);
                    
                    if (!optHandler.allowMultiple()) {
                        break;
                    }
                }
            }
        } catch (CommandLineOptionHandler.FatalException e) {
            // Validation went wrong. Show and exit.
            if (e.getThrowable() == null) {
                Log.add(e.getMessage());
            } else {
                Log.add(e.getMessage(), e.getThrowable());
            }
            return false;
        }
        
        
        // Restructure the argument handlers so we can process them according to their priority.
        final Map<Integer, List<CommandLineOptionHandler>> map = new TreeMap<>();
        for (CommandLineOptionHandler argumentHandler : usedHandlers) {
            final List<CommandLineOptionHandler> handlerToAdd = new LinkedList<>();
            handlerToAdd.add(argumentHandler);
            if (map.containsKey(argumentHandler.getProcessPriority())) {
                map.get(argumentHandler.getProcessPriority()).addAll(handlerToAdd);
            } else {
                map.put(argumentHandler.getProcessPriority(), handlerToAdd);
            }
        }

        // Process arguments in order.
        int handledArguments = 0;
        try {
            for (Map.Entry<Integer, List<CommandLineOptionHandler>> entry : map.entrySet()) {
                for (CommandLineOptionHandler argumentHandler : entry.getValue()) {
                    argumentHandler.process(this);
                    handledArguments++;
                }
            }
        } catch (CommandLineOptionHandler.FatalException e) {
            // Validation went wrong. Only show the information. Exit is coming up.
            if (e.getThrowable() == null) {
                Log.add(e.getMessage());
            } else {
                Log.add(e.getMessage(), e.getThrowable());
            }
        }
        
        return handledArguments == usedHandlers.size();
    }

}